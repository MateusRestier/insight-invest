#FEITO 
Remover imputer do classficador, e selecionar novas features para usar no classificador e recomendador, 
nao pode ser nenhuma dessas pq elas tem nulo no banco:
psr
ev_ebitda
p_ebitda
div_liq_patrimonio
div_liq_ebitda
div_liq_ebit
div_bruta_patrimonio
liquidez_corrente

Entender se com mais dados, piora o modelo, pq vao ter varias linhas praticamente iguais da msm ação.

imprementar Validação Cruzada Temporal pra evitar o problema 5

Criar outro código que preveja o valor das features das ações (ver como fazer) # opcional (ele ve o preço futuro)

O regressor atualmente preve dias q ja passaram, agr quero efetivamente prever o futuro, ou seja, prever o preço da ação daqui 10 dias e salvar isso de alguma forma pra exibir dps no site

data da previsao no regressor acho q ta errado, ela fica igual a data da coleta, a intenção é ver q dia q a previsao "foi feita" e o dia q ela está prevendo,
além da data da coleta em si (a data da coleta n é pra ter nd haver com o codigo, ela vai preencher automatico), tem q ter a data da previsão (q está simulando q ta rodando) e a data q tentou prever
5518	ABEV3	2025-06-16	13.640000	14.053893	3.0344	2025-06-16




na pagina do recomendador, colocar pra mostrar tb o scraping igual atualmente ta no indicadores

mostrar as infos q tenho do banco, pra outro chat de gpt e pedir oq ele faria num power bi, e tentar aplicar no dash de python


# A FAZER

Entender melhor como o docker funciona

a intenção é transofrmar a pagina do indicadores em um dashboard mesmo(provavelmente trocar o nome da aba tb), e as outras explorando mais o regressor e recomendador

descobrir oq colocar de informação no indicadores alem do grafico com dropdown, derrepente cards q viram quando passa o mouse, ou algo assim

usar consultas personalizadas q eu tinha feito tb (ABAIXO) #fazendo

pedir pra tabela do indicadores ficar so metade da pagina, pq ao lado vou querer colocar cards com algumas métricas em relação à ela, os cards podem rodar mostrando alguma coisa quando passa o mouse em cima
(media de acerto do preço real e previsto, quantidade de dias previstos, quantidade de acertos exatos erro_pct = 0, quantidade de erros pra cima erro_pct > 0, quantidade de erros pra baixo erro_pct < 0)

fazer os filtros da elgenda do grafico de pizza sincronziar coma tabela

ordenar a tabela por data calculo ASC

alinhar o grafico de pizza

trocar pizza pra rosca e colocar cards no meio mostrando a média de erro pra cima e pra baixo














--- CONSULTA PRA COMPARAR O PREÇO PREVISTO, COM O PREÇO REAL

SELECT
    r.acao,
    r.data_calculo,
    r.data_previsao,
    r.preco_previsto,
    i.cotacao AS preco_real,
    CASE
        WHEN i.cotacao IS NOT NULL AND i.cotacao <> 0 THEN
            ROUND((r.preco_previsto - i.cotacao) / i.cotacao * 100, 4)
        ELSE NULL
    END AS erro_pct
FROM
    resultados_precos r
LEFT JOIN
    indicadores_fundamentalistas i
    ON r.acao = i.acao
    AND r.data_previsao = i.data_coleta
ORDER BY
    r.data_calculo,
    r.acao;

delete from resultados_precos where 1=1;

--- CONSULTA PARA CALCULAR O MAE, MSE E R2 REAL DA TABELA TOTAL

WITH comparacao AS (
    SELECT
        r.acao,
        r.data_calculo,
        r.data_previsao,
        r.preco_previsto,
        i.cotacao AS preco_real,
        (r.preco_previsto - i.cotacao) AS erro,
        POWER(r.preco_previsto - i.cotacao, 2) AS erro_quadrado
    FROM
        resultados_precos r
    LEFT JOIN
        indicadores_fundamentalistas i
        ON r.acao = i.acao
        AND r.data_previsao = i.data_coleta
    WHERE
        i.cotacao IS NOT NULL
)
SELECT
    COUNT(*) AS total_registros,
    ROUND(AVG(ABS(erro)), 6) AS mae_real,
    ROUND(AVG(erro_quadrado), 6) AS mse_real,
    ROUND(
        1 - SUM(erro_quadrado) / NULLIF(SUM(POWER(preco_real - (SELECT AVG(preco_real) FROM comparacao), 2)), 0),
        6
    ) AS r2_real
FROM
    comparacao;


--- ✅ 1) MAE, MSE e R² por data_previsao (dia previsto):

WITH comparacao AS (
    SELECT
        r.acao,
        r.data_calculo,
        r.data_previsao,
        r.preco_previsto,
        i.cotacao AS preco_real,
        (r.preco_previsto - i.cotacao) AS erro,
        POWER(r.preco_previsto - i.cotacao, 2) AS erro_quadrado
    FROM
        resultados_precos r
    LEFT JOIN
        indicadores_fundamentalistas i
        ON r.acao = i.acao
        AND r.data_previsao = i.data_coleta
),
datas AS (
    SELECT DISTINCT data_previsao FROM resultados_precos
),
media_por_previsao AS (
    SELECT
        data_previsao,
        AVG(preco_real) AS media_preco_real
    FROM
        comparacao
    GROUP BY
        data_previsao
)
SELECT
    d.data_previsao,
    COUNT(c.acao) AS total_registros,
    ROUND(AVG(ABS(c.erro)), 6) AS mae_real,
    ROUND(AVG(c.erro_quadrado), 6) AS mse_real,
    ROUND(
        1 - SUM(c.erro_quadrado) / NULLIF(SUM(POWER(c.preco_real - m.media_preco_real, 2)), 0),
        6
    ) AS r2_real
FROM
    datas d
LEFT JOIN comparacao c
    ON d.data_previsao = c.data_previsao
LEFT JOIN media_por_previsao m
    ON d.data_previsao = m.data_previsao
GROUP BY
    d.data_previsao, m.media_preco_real
ORDER BY
    d.data_previsao;



--- ✅ 2) MAE, MSE e R² por data_calculo (dia em que a previsão foi feita):

WITH comparacao AS (
    SELECT
        r.acao,
        r.data_calculo,
        r.data_previsao,
        r.preco_previsto,
        i.cotacao AS preco_real,
        (r.preco_previsto - i.cotacao) AS erro,
        POWER(r.preco_previsto - i.cotacao, 2) AS erro_quadrado
    FROM
        resultados_precos r
    LEFT JOIN
        indicadores_fundamentalistas i
        ON r.acao = i.acao
        AND r.data_previsao = i.data_coleta
),
datas AS (
    SELECT DISTINCT data_calculo FROM resultados_precos
),
media_por_calculo AS (
    SELECT
        data_calculo,
        AVG(preco_real) AS media_preco_real
    FROM
        comparacao
    GROUP BY
        data_calculo
)
SELECT
    d.data_calculo,
    COUNT(c.acao) AS total_registros,
    ROUND(AVG(ABS(c.erro)), 6) AS mae_real,
    ROUND(AVG(c.erro_quadrado), 6) AS mse_real,
    ROUND(
        1 - SUM(c.erro_quadrado) / NULLIF(SUM(POWER(c.preco_real - m.media_preco_real, 2)), 0),
        6
    ) AS r2_real
FROM
    datas d
LEFT JOIN comparacao c
    ON d.data_calculo = c.data_calculo
LEFT JOIN media_por_calculo m
    ON d.data_calculo = m.data_calculo
GROUP BY
    d.data_calculo, m.media_preco_real
ORDER BY
    d.data_calculo;



--- ✅ 3) MAE, MSE e R² por ação (ticker):

WITH comparacao AS (
    SELECT
        r.acao,
        r.data_calculo,
        r.data_previsao,
        r.preco_previsto,
        i.cotacao AS preco_real,
        (r.preco_previsto - i.cotacao) AS erro,
        POWER(r.preco_previsto - i.cotacao, 2) AS erro_quadrado
    FROM
        resultados_precos r
    LEFT JOIN
        indicadores_fundamentalistas i
        ON r.acao = i.acao
        AND r.data_previsao = i.data_coleta
    WHERE
        i.cotacao IS NOT NULL
),
media_por_acao AS (
    SELECT
        acao,
        AVG(preco_real) AS media_preco_real
    FROM
        comparacao
    GROUP BY
        acao
)
SELECT
    c.acao,
    COUNT(*) AS total_registros,
    ROUND(AVG(ABS(c.erro)), 6) AS mae_real,
    ROUND(AVG(c.erro_quadrado), 6) AS mse_real,
    ROUND(
        1 - SUM(c.erro_quadrado) / NULLIF(SUM(POWER(c.preco_real - m.media_preco_real, 2)), 0),
        6
    ) AS r2_real
FROM
    comparacao c
JOIN
    media_por_acao m
    ON c.acao = m.acao
GROUP BY
    c.acao, m.media_preco_real
ORDER BY
    c.acao;
